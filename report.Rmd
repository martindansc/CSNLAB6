---
title: 'CSN: lab 6'
author: "Sergio H. Martínez Mateu, Martín Dans"
date: "28/11/2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, cache = TRUE, fig.width = 6, fig.height = 4, fig.show = "hold", out.width = "75%")
library(data.table)
library(igraph)
library(nlstools) # For NLS
library(minpack.lm) # For NLS2
library(stats4) # For MLE
library(viridis) # Plots
library(VGAM) # For the Riemann-Zeta function
library(kableExtra) # For tables
library(ggplot2)
```

# Input
```{r}
# versions <- c("BA", "BA_RA", "BA_NG")
# names(versions) <- c("Barabasi-Albert", "Random Attachment", "No growth")

versions <- c("BA", "BA_RA", "BA_NG")
names(versions) <- c("Barabasi-Albert", "Random Attachment", "No Growth")

m0 <- c(10, 10 , 10)
n0 <- c(10, 100, 10000)
tmax <- 10000
arrivalTimes <- c(1, 10, 100, 1000)
names(m0) <- names(n0) <- versions
```

## Degree distribution

```{r}
degreeDistributions <- vector(mode = "list", length = length(versions))
names(degreeDistributions) <- versions
for(v in versions){
  # Read degree distribution files
  degrees <- fread(paste0("out/",v,"/degreees.txt"), data.table = F)
  degrees <- unname(t(degrees)[,1])
  
  # Store them in list    
  degreeDistributions[[v]] <- degrees[1:tmax]
}
```

## Degree evolution
```{r}
degreeOverTime <- vector(mode = "list", length = length(versions))
names(degreeOverTime) <- versions
for(v in versions){
  # List files
  files <- list.files(paste0("out/", v))
  ts.files <- files[grep("tracked", files)]
  
  # Read time series files
  timeseries <- data.frame(matrix(NA, nrow = 4, ncol = tmax, dimnames = list(x = paste0("AT", arrivalTimes), y = 1:tmax)))
  for(i in 1:length(ts.files)){
    dot <- fread(paste0("out/", v, '/', ts.files[i]), data.table = F)
    dot <- unname(t(dot)[,1])
    timeseries[i,] <- dot
  }
  
  ts <- reshape(data = timeseries, varying = names(timeseries), v.names = "degree", 
                timevar = "t", sep = "", direction = "long", idvar = "ti", ids = arrivalTimes)
  rownames(ts) <- 1:nrow(ts)
  
  # Don't consider ki(t) = 0 for t < ti
  if(sum(ts$degree==0)>0) ts <- ts[-which(ts$degree == 0 ),]
  
  # Scaled version of ki(t)
  if(v == "BA") ts$degree <- ts$degree*sqrt(ts$ti)
  if(v == "BA_RA") ts$degree <- ts$degree + m0[v]*log(n0[v]+ts$ti-1)-m0[v]

  # Store it in list
  degreeOverTime[[v]] <- ts
}
```


# Time-series 
## Functions
### Models 
```{r}
# Function to generate a list of maximum likelihood given a set of sequence statistics
TSmodel_names <- c('0', '1', '2', '3', '4', '0+', '1+', '2+', '3+', '4+')
TSnum_params <- c(1, 1, 2, 2, 2, 2, 2, 3, 3, 3)
TSmodels <- 
  c(
    # Model 0
    as.formula("degree~a*t"),

    # Model 1
    as.formula("degree~a*t^(1/2)"),

    # Model 2
    as.formula("degree~a*t^b"),

    # Model 3
    as.formula("degree~a*exp(c*t)"),
    
    # Model 4
    as.formula("degree~a*log(t+d1)"),

    # Model 0+
    as.formula("degree~a*t+d"),

    # Model 1+
    as.formula("degree~a*t^(1/2)+d"),

    # Model 2+
    as.formula("degree~a*t^b+d"),

    # Model 3+
    as.formula("degree~a*exp(c*t)+d"),
    
    # Model 4+
    as.formula("degree~a*log(t+d1)+d2")
  )
```

### Starting parameters

```{r}
TSstart_parameters_v0 <- function(dat, plus = FALSE) {
  if(plus == FALSE){
    linear_model = lm(degree ~ t-1, dat)
    a_initial <- coef(linear_model)[1]
    if(abs(a_initial) < 1e-3) a_initial <- a_initial + sign(a_initial)*0.05
    list(a = a_initial)
  } else{
    linear_model = lm(degree ~ t, dat)
    a_initial <- coef(linear_model)[2]
    d_initial <- coef(linear_model)[1]
    if(abs(a_initial) < 1e-3) a_initial <- a_initial + sign(a_initial)*0.05
    list(a = a_initial, d = d_initial)
  }
}

TSstart_parameters_v1 <- function(dat, plus = FALSE) {
  if(plus == FALSE){
    linear_model = lm(degree ~ sqrt(t)-1, dat)
    a_initial <- coef(linear_model)[1]
    if(abs(a_initial) < 1e-3) a_initial <- a_initial + sign(a_initial)*0.05
    list(a = a_initial)
  } else{
    linear_model = lm(degree ~ sqrt(t), dat)
    a_initial <- coef(linear_model)[2]
    d_initial <- coef(linear_model)[1]
    if(abs(a_initial) < 1e-3) a_initial <- a_initial + sign(a_initial)*0.05
    list(a = a_initial, d = d_initial)
  }
}

TSstart_parameters_v2 <- function(dat, plus = FALSE) {
  if(plus == FALSE){
    linear_model = lm(log(degree) ~ log(t), dat)
    a_initial = exp(coef(linear_model)[1])
    b_initial = coef(linear_model)[2]
    if(abs(b_initial) < 1e-3) b_initial <- b_initial + sign(b_initial)*0.5
    list(a = a_initial, b = b_initial)
  } else{
    linear_model = lm(log(degree) ~ log(t), dat)
    a_initial = exp(coef(linear_model)[1])
    b_initial = coef(linear_model)[2]
    if(abs(b_initial) < 1e-3) b_initial <- b_initial + sign(b_initial)*0.5
    list(a = a_initial, b = b_initial, d = 0)
  }
}

TSstart_parameters_v3 <- function(dat, plus = FALSE) {
  if(plus == FALSE){
    linear_model = lm(log(degree) ~ t, dat)
    a_initial = exp(coef(linear_model)[1])
    c_initial = coef(linear_model)[2]
    if(abs(c_initial) < 1e-3) c_initial <- c_initial + sign(c_initial)*0.005
    list(a = a_initial, c = c_initial)
  } else{
    linear_model = lm(log(degree) ~ t, dat)
    a_initial = exp(coef(linear_model)[1])
    c_initial = coef(linear_model)[2]
    if(abs(c_initial) < 1e-3) c_initial <- c_initial + sign(c_initial)*0.005
    list(a = a_initial, c = c_initial, d = 0)
  }
}

TSstart_parameters_v4 <- function(dat, plus = FALSE) {
  if(plus == FALSE){
    linear_model = lm(degree ~ log(t)-1, dat)
    a_initial <- unname(coef(linear_model)[1])
    if(abs(a_initial) < 1e-3) a_initial <- a_initial + sign(a_initial)*0.05
    list(a = a_initial, d1 = 0)
  } else{
    linear_model = lm(degree ~ log(t), dat)
    a_initial <- unname(coef(linear_model)[2])
    d2_initial <- coef(linear_model)[1]
    if(abs(a_initial) < 1e-3) a_initial <- a_initial + sign(a_initial)*0.5
    list(a = a_initial, d1 = 0, d2 = d2_initial)
  }
}

TSstart_parameters <- function(dat,i){
    if (i==1) return(TSstart_parameters_v0(dat))                      # Model 0
    if (i==2) return(TSstart_parameters_v1(dat))                      # Model 1
    if (i==3) return(TSstart_parameters_v2(dat))                      # Model 2
    if (i==4) return(TSstart_parameters_v3(dat))                      # Model 3
    if (i==5) return(TSstart_parameters_v4(dat))                      # Model 4
    if (i==6) return(TSstart_parameters_v0(dat, T))                       # Model 0+
    if (i==7) return(TSstart_parameters_v1(dat, T))                       # Model 1+
    if (i==8) return(TSstart_parameters_v2(dat, T))                       # Model 2+
    if(i==9)  return(TSstart_parameters_v3(dat, T))                       # Model 3+
    if(i==10) return(TSstart_parameters_v4(dat, T))                       # Model 4+
}
```

### Solving NLS

```{r}
# Calculate optimal parameters nls
solveAllModels <- function(data) {
  lapply(1:length(TSmodels), function(i) {
    print(paste("Computing model", i))
    if(TSnum_params[i] > 0) {
          nls(formula = TSmodels[[i]],
              data = data,
              start = TSstart_parameters(data,i),
              control = nls.control(maxiter = 3000, tol = 1e-05, warnOnly=T)
              #algorithm = "Gauss-Newton",
              #lower = lower_bounds[[i]](stats),
              #upper = upper_bounds[[i]](stats)
          )
    }
  })
}

# Calculate optimal parameters with nlsLM (a different package)
solveAllModels2 <- function(data) {
  lapply(1:length(TSmodels), function(i) {
    print(paste("Computing model", i))
    if(TSnum_params[i] > 0) {
      try(nlsLM(formula = TSmodels[[i]],
              data = data,
              start = TSstart_parameters(data,i)
              #algorithm = "Gauss-Newton",
              #lower = lower_bounds[[i]](stats),
              #upper = upper_bounds[[i]](stats)
          ))
          
    }
  })
}

# Solve for all chosen vertices
solve1Version <- function(version){
  lapply(arrivalTimes, function(x) solveAllModels2(degreeOverTime[[version]][degreeOverTime[[version]]$ti==x,]))
}
```

## Fitting models (NLS)
```{r message=FALSE, warning=FALSE, include=FALSE}
nls_results <- lapply(versions, solve1Version)
names(nls_results) <- versions
```

### Calculating AICs

```{r}
# Get AICs
table2 <- data.frame(expand.grid(versions,arrivalTimes))
table2 <- table2[order(table2$Var1),]
table2 <- cbind(table2, matrix(NA, nrow = nrow(table2), ncol = length(TSmodels)))
names(table2) <- c("Version", "ArrivalTime", TSmodel_names)
for(v in 1:length(versions)){
  for(a in 1:length(arrivalTimes)){
    for(i in 1:length(TSmodels)){
      table2[table2$Version==versions[v] & table2$ArrivalTime == arrivalTimes[a], TSmodel_names[i]] <- AIC(nls_results[[v]][[a]][[i]])
    }
  }
}

# AIC difference  
table2Dif <- table2
table2Dif[,TSmodel_names] <- table2Dif[,TSmodel_names]-apply(table2Dif[,TSmodel_names], 1, min)
```

### Plotting 

```{r}
# Evolution plots + theoretical curve
plotEvolutions <- function(version){

  m <- m0[version]
  n <- n0[version]
  
  theoreticalCurves <- list(
    BA = function(x)m * sqrt(x),
    BA_RA = function(x) m*log(m+x-1),
    BA_NG = function(x) 2*m*x/n
  )
  
  ggplot(degreeOverTime[[version]], aes(x = t, y = degree)) + 
  geom_line(aes(color = as.factor(ti)), size = 1) +
  theme_minimal() + labs(color = "Arrival time") + 
  labs(color = NULL, y = "Scaled degree", x = "Time step") +
  stat_function(fun=theoreticalCurves[[version]], geom="line", mapping = aes(color = "Theoretical")) +
  scale_color_manual(values = c(2,3,4,5,1),
  labels=c(paste("AT", arrivalTimes), "Theoretical curve"))
}
```

## Retrieving the coefficients of the models

```{r}
# Table 3
# TODO: error getting the coefficients, should be something like: coefficients(nls_results[["Barabasi-Albert"]][[1]][[1]])
# get_paramsTS <- function(version){
#   do.call(c,lapply(1:length(TSmodels), function(x) coefficients(nls_results[[version]][[x]])))
# }
# TS_params <- do.call(rbind, lapply(names(versions), function(x) get_paramsTS(x)))
# rownames(TS_params) <- names(ts)
```

# Degree distribution functions

## Functions
```{r}
DDmodel_names <- c('DisplacedPoisson', 'DisplacedGeometric', 'RestrictedZeta', 'Zeta', 'RightTZeta', 'Altmann')
DDnum_params <- c(1, 1, 0, 1, 2, 2)
x <- numeric()
computeMinusLogLik <- list(
  
  DisplacedPoisson = function(lambda) {
    C <- sum(sapply(x, function(y) sum(log(2:y))))
    return(-sum(x) * log(lambda) + length(x) * (lambda + log(1 - exp(-lambda))) + C)
  },
  
  DisplacedGeometric = function(q) -(sum(x)-length(x)) * log(1-q) - length(x) * log(q),
  
  RestrictedZeta = function() {
    M <- sum(log(x))
    return(3 * M + length(x) * log(zeta(3, deriv = 0)))
  },
  
  Zeta = function(gamma) {
    M <- sum(log(x))
    return(gamma * M + length(x) * log(zeta(gamma, deriv = 0)))
  },
  
  RightTZeta = function(gamma, kmax) {
    M <- sum(log(x))
    return(gamma * M + length(x) * log(sum((1:kmax)^(-gamma))))
  },
  
  Altmann = function(gamma, delta) {
    cinv <- sum(sapply(1:length(x),function(k) k^(-gamma)*exp(-delta*k)))
    return(delta * sum(x) + gamma * sum(log(x)) + length(x) * log(cinv))
  }
)

computeProbability <- list(
  DisplacedPoisson   = function(x, lambda) lambda^x*exp(-lambda)/(factorial(x)*(1-exp(-lambda))),
  DisplacedGeometric = function(x, q) (1-q)^(x-1)*q,
  RestrictedZeta     = function(x) x^-3/zeta(3, deriv = 0),
  Zeta               = function(x, gamma) x^(-gamma)/zeta(gamma, deriv = 0),
  RightTZeta         = function(x, gamma, kmax) x^(-gamma)/sum((1:kmax)^(-gamma)),
  Altmann            = function(x, gamma, delta) {
    cinv <- sum(sapply(1:length(x), function(k) k^(-gamma) * exp(-delta*k)))
    x^(-gamma)*exp(-delta*x)/cinv
  }
)

startParameters <- list(
  startDP = list(lambda = 1),
  startDG = list(q = 1),
  startRZ = NULL,
  startZ  = list(gamma = 3),
  startRTZ= list(gamma = 0.05, kmax = max(x)),
  startMA  = list(gamma = 1, delta = 0)
)

bounds <- list(
  boundsDP = list(lower = 1e-7, upper = NA),
  boundsDG = list(lower = 1e-7, upper = 1-1e-7),
  boundsRZ = list(lower = NA, upper = NA),
  boundsZ  = list(lower = 1+1e-7, upper = NA),
  boundsRTZ= list(lower = c(1, max(x)), upper = NA),
  boundsMA = list(lower = c(0,0), upper = NA)
)

NModels <- length(computeMinusLogLik)

calculateMLE <- function(version){
  x <<- degreeDistributions[[version]]
  res <- lapply(1:NModels, function(i) {
    print(paste("Computing model", names(computeMinusLogLik)[i]))
    if(DDnum_params[i] > 0) {
          mle(minuslogl = computeMinusLogLik[[i]],
              start = startParameters[[i]],
              method = "L-BFGS-B",
              lower = bounds[[i]]$lower,
              upper = bounds[[i]]$upper)
    } else NULL
  })#lapply
  names(res) <- names(computeMinusLogLik)
  return(res)
}

# Sample size corrected AIC function
get_AIC <- function(m2logL,K,N) {
m2logL + 2*K*N/(N-K-1) 
}

# Plot fitted vs real
visualizeDDFit <- function(version, whichModels = 1:length(mle_models[[version]])){
  for(i in whichModels){
    
    # Get parameters
    if(DDnum_params[i] > 0){
      opt_params <- coef(mle_models[[version]][[i]])
    } else{
      opt_params <- NULL
    }
    
    # Get data
    degrees <- degreeDistributions[[version]]
    degree_spectrum <- table(degrees)
    counts <- unname(degree_spectrum)
    spectrum <- as.numeric(names(degree_spectrum))
    
    # Plot
    plot(spectrum, counts, log = "xy", ylim = c(1, tmax), col=viridis(length(spectrum)))
    lines(spectrum, 
          length(x)*sapply(spectrum, function(z) do.call(computeProbability[[i]], as.list(c(x=z, opt_params)))),
          col = "darkorchid", lwd=3)
    legend('topright', legend=parse(text=names(mle_models[[version]])[i]), col='darkorchid', lwd=3)
  }
}
```

## Fitting models (MLE)

```{r}
mle_models <- list()
for (version in names(degreeDistributions)){
  print(version)
  if(!is.null(degreeDistributions[[version]])) mle_models[[version]] <- calculateMLE(version)
}
```


## Evaluating
```{r}
computeAICs <- function(models, N){
  sapply(1:length(models), function(i){
    if(is.null(models[[i]])){
      m2LL <- 2*computeMinusLogLik[[i]]
    } else{
      m2LL <- attributes(summary(models[[i]]))$m2logL
    }
    get_AIC(m2LL, DDnum_params[i], N)
  })
}

AICs <- do.call(rbind, lapply(names(degreeDistributions), function(v) computeAICs(mle_models[[v]], length(degreeDistributions[[v]]))))

aic_df <- as.data.frame(do.call(rbind, stat$aic))
colnames(aic_df) <- DDmodel_names

DDresults <- list(aic=aic_df, delta=d_aic_df)
```


# Introduction
The goal of this laboratory work is to study ...

# Results

Here are the parameters that were used in our simulations of network generating models:
```{r}
kable(data.frame(Version = names(versions), m0 = m0, n0 = n0, InitialConf = c("A", "B", "C")), row.names = F)
```


## Degree evolution

The first thing that we want to check is that the evolution of the degrees over the time generation steps follow approximately the corresponding theoretical curves. To do this, we rescaled the degree for which the curve should be indenpendent of the arrival time, i.e., similar for each of the vertices. At the same time, we plot the theoretical curve.

```{r}
plotEvolutions("BA")
plotEvolutions("BA_RA")
plotEvolutions("BA_NG")
```

```{r}
# Table AIC
# print(kable(table2, align = "c", caption = paste("AIC results for the time series data")) %>% 
#   kable_styling(latex_options = c("striped", "hold_position")))

# Table AIC diff
table2Dif[,3:ncol(table2Dif)] <- round(table2Dif[,3:ncol(table2Dif)], 1)

print(kable(table2Dif, align = "c", caption = paste("AIC difference results for the time series data")) %>% 
  kable_styling(latex_options = c("striped", "hold_position")))

# print(kable(table2Dif[,1:7], align = "c", caption = paste("AIC difference results for the time series data")) %>% 
#   kable_styling(latex_options = c("striped", "hold_position")))
# 
# print(kable(table2Dif[,c(1:2,8:ncol(table2Dif))], align = "c", caption = paste("AIC difference results for the time series data")) %>% 
#   kable_styling(latex_options = c("striped", "hold_position")))

```



## Degree distribution

Plots
```{r}
visualizeDDFit("BA")
visualizeDDFit("BA_RA")
visualizeDDFit("BA_NG")
```

AIC tables
```{r}
# Table AIC
print(kable(round(DDresults$aic, digits = 2), align = "c", caption = paste("AIC results for the degree distribution data")) %>% 
  kable_styling(latex_options = c("striped", "hold_position")))

# Table AIC diff
print(kable(round(DDresults$delta,digits = 2), align = "c", caption = paste("AIC difference results for the degree distribution data")) %>% 
  kable_styling(latex_options = c("striped", "hold_position")))

```


# Discussion

# Methods


